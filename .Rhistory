texto1 <- as.data.frame(texto1)
paged_table(texto1)
transforme_sobre_texto <- tolower(texto1)
transforme_sobre_texto <- removePunctuation(transforme_sobre_texto)
transforme_sobre_texto <- removeNumbers(transforme_sobre_texto)
transforme_sobre_texto <- stripWhitespace(transforme_sobre_texto)
stopwords_pt <- c(stopwords("pt"), "o", "é", "do", "ser", "nesse", "mas")
stopwords_pt <- c(
"de",
"a",
"o",
"que",
"e",
"do",
"da",
"em",
"um",
"para",
"com",
"não",
"uma",
"os",
"no",
"se",
"na",
"por",
"mais",
"as",
"dos",
"como",
"mas",
"foi",
"ao",
"ele",
"das",
"tem",
"à",
"seu",
"sua",
"ou",
"ser",
"quando",
"muito",
"há",
"nos",
"já",
"está",
"eu",
"também",
"só",
"pelo",
"pela",
"até",
"isso",
"ela",
"entre",
"depois",
"sem",
"mesmo",
"aos",
"ter",
"seus",
"quem",
"nas",
"me",
"esse",
"eles",
"estão",
"você",
"tinha",
"foram",
"essa",
"num",
"nem",
"suas",
"meu",
"às",
"minha",
"têm",
"numa",
"pelos",
"elas",
"havia",
"seja",
"qual",
"será",
"nós",
"tenho",
"lhe",
"deles",
"essas",
"esses",
"pelas",
"este",
"fosse",
"dele",
"tu",
"te",
"vocês",
"vos",
"lhes",
"meus",
"minhas",
"teu",
"tua",
"teus",
"tuas",
"nosso",
"nossa",
"nossos",
"nossas",
"dela",
"delas",
"esta",
"estes",
"estas",
"aquele",
"aquela",
"aqueles",
"aquelas",
"isto",
"aquilo",
"estou",
"está",
"estamos",
"estão",
"estive",
"esteve",
"estivemos",
"estiveram",
"estava",
"estávamos",
"estavam",
"estivera",
"estivéramos",
"esteja",
"estejamos",
"estejam",
"estivesse",
"estivéssemos",
"estivessem",
"estiver",
"estivermos",
"estiverem",
"hei",
"há",
"havemos",
"hão",
"houve",
"houvemos",
"houveram",
"houvera",
"houvéramos",
"haja",
"hajamos",
"hajam",
"houvesse",
"houvéssemos",
"houvessem",
"houver",
"houvermos",
"houverem",
"houverei",
"houverá",
"houveremos",
"houverão",
"houveria",
"houveríamos",
"houveriam"
)
transforme_sobre_texto  <- removeWords(transforme_sobre_texto , stopwords_pt)
print(transforme_sobre_texto)
wordcloud(transforme_sobre_texto, scale = c(8, 0.5), max.words = 20, color = wes_palette("Royal1"))
wordcloud(transforme_sobre_texto, scale = c(8, 0.5), max.words = 40, color = wes_palette("Royal1"))
wordcloud(transforme_sobre_texto, scale = c(10, 0.5), max.words = 40, color = wes_palette("Royal1"))
wordcloud(transforme_sobre_texto, scale = c(6, 0.5), max.words = 40, color = wes_palette("Royal1"))
print(transforme_sobre_texto)
dados_post <- list("title" = "mineracao",
"autor" = "blog",
"content" = transforme_sobre_texto)
json_dados <- toJSON(dados_post, auto_unbox = TRUE)
print(json_dados)
response <- POST(
url,
body = json_dados,
encode = "json",
add_headers("Content-Type" = "application/json")
)
# Verificando o status da resposta
print(status_code(response))
# Verificando o conteúdo da resposta
print(content(response, "text"))
print(data_get)
response <- GET(url = url)
# Verificando o status da resposta
if (status_code(response) == 200) {
# Convertendo o conteúdo JSON em um dataframe
data <- fromJSON(content(response, "text"), flatten = TRUE)
print(data)
} else {
cat("Erro na requisição:", status_code(response))
}
# Convertendo o conteúdo JSON em um dataframe
data <- fromJSON(content(response, "texts"), flatten = TRUE)
print(data)
response <- GET(url = url)
# Verificando o status da resposta
if (status_code(response) == 200) {
# Convertendo o conteúdo JSON em um dataframe
data <- fromJSON(content(response, "texts"), flatten = TRUE)
print(data)
} else {
cat("Erro na requisição:", status_code(response))
}
# Convertendo o conteúdo JSON em um dataframe
data <- fromJSON(content(response), flatten = TRUE)
print(data)
dados_post <- list("title" = "mineracao",
"autor" = "blog",
"content" = transforme_sobre_texto)
json_dados <- toJSON(dados_post, auto_unbox = TRUE)
print(json_dados)
response <- POST(
url,
body = json_dados,
encode = "json",
add_headers("Content-Type" = "application/json")
)
# Verificando o status da resposta
print(status_code(response))
# Verificando o conteúdo da resposta
print(content(response, "text"))
if (status_code(response_get) == 200) {
# Convertendo o conteúdo JSON em um dataframe
data_get <- fromJSON(content(response_get, "text"), flatten = TRUE)
print(data_get)
} else {
cat("Erro na requisição:", status_code(response_get))
}
# Verificando o conteúdo da resposta
print(content(response[0], "content"))
response <- GET(url)
# Verificando o status da resposta
status <- status_code(response)
if (status == 200) {
# Convertendo o conteúdo JSON em um objeto R
data <- fromJSON(content(response, "text"))
# Verificando a estrutura dos dados
print(str(data))
# Exibindo os dados
print(data)
} else {
cat("Erro na requisição. Status code:", status, "\n")
}
# Convertendo o conteúdo JSON em um objeto R
data <- fromJSON(content(response, "text"))
fazer_requisicao <- function(url) {
tryCatch({
response <- GET(url)
status <- status_code(response)
if (status == 200) {
response_text <- content(response, as = "text", encoding = "UTF-8")
data <- fromJSON(response_text)
print(str(data))
print(data)
} else {
cat("Erro na requisição. Status code:", status, "\n")
}
}, error = function(e) {
cat("Ocorreu um erro:", conditionMessage(e), "\n")
}, finally = {
cat("Requisição finalizada.\n")
})
}
# Chamar a função
fazer_requisicao(url)
fazer_requisicao <- function(url) {
tryCatch({
response <- GET(url)
status <- status_code(response)
if (status == 200) {
response_text <- content(response, as = "text")  # Sem o encoding
data <- fromJSON(response_text)
print(str(data))
print(data)
} else {
cat("Erro na requisição. Status code:", status, "\n")
}
}, error = function(e) {
cat("Ocorreu um erro:", conditionMessage(e), "\n")
}, finally = {
cat("Requisição finalizada.\n")
})
}
# Chamar a função
fazer_requisicao(url)
texto_c <- read_html(c("https://www.baguete.com.br/noticias/30/10/2020/ciencia-de-dados-continuara-sendo-a-grande-profissao-do-futuro"))
texto_corpus <-  texto_c %>%
html_nodes("p") %>%
html_text()
corpus_texto <-VCorpus(VectorSource(texto_corpus))
corpus_texto <- tm_map(corpus_texto, removePunctuation)
corpus_texto <- tm_map(corpus_texto, removeNumbers)
corpus_texto <- tm_map(corpus_texto, removeWords, stopwords("pt"))
dtm_texto <- DocumentTermMatrix(corpus_texto)
dtm_texto
View(dtm_texto)
texto_t <- read_html(c("https://www.baguete.com.br/noticias/30/10/2020/ciencia-de-dados-continuara-sendo-a-grande-profissao-do-futuro"))
texto_tidy <-  texto_t %>%
html_nodes("p") %>%
html_text()
texto_df <- data_frame(text = texto_tidy)
texto_token <- texto_df %>%
unnest_tokens(word, text)
stopwords_portu_df <- data.frame(word = stopwords_pt)
texto_token <- texto_token %>%
anti_join(stopwords_portu_df, by = "word")
texto_token %>%
count(word, sort = TRUE)
texto_token %>%
count(word, sort = TRUE) %>%
filter(n > 3) %>%
mutate(word = reorder(word, n)) %>%
ggplot(aes(word, n)) +
geom_col(fill = "#245968") +
xlab(NULL) +
coord_flip() +
labs(y = "Frequência Termos")
response <- GET(url = url)
print(response)
print(response.data)
print(response.content)
print(response[1])
print(response[5])
print(response[6])
# Convertendo o conteúdo JSON em um dataframe
data <- fromJSON(content(response[6], "text"), flatten = TRUE)
# Convertendo o conteúdo JSON em um dataframe
data <- fromJSON(content(response[6], "texts"), flatten = TRUE)
# Convertendo o conteúdo JSON em um dataframe
data <- fromJSON(content(response[6], "content"), flatten = TRUE)
print(response[6])
# Convertendo o conteúdo JSON em um dataframe
data <- fromJSON(content(response, "content"), flatten = TRUE)
print(data)
# Convertendo o conteúdo JSON em um dataframe
data <- fromJSON(content(response[6]), flatten = TRUE)
# Convertendo o conteúdo JSON em um dataframe
data <- fromJSON(content(response, response[6]), flatten = TRUE)
# Convertendo o conteúdo JSON em um dataframe
data <- fromJSON(content(response, content), flatten = TRUE)
fazer_requisicao <- function(url) {
tryCatch({
response <- GET(url)
status <- status_code(response)
if (status == 200) {
response_text <- content(response, type = "text", encoding = "UTF-8")  # Correção aqui
data <- fromJSON(response_text)
print(str(data))
print(data)
} else {
cat("Erro na requisição. Status code:", status, "\n")
}
}, error = function(e) {
cat("Ocorreu um erro:", conditionMessage(e), "\n")
}, finally = {
cat("Requisição finalizada.\n")
})
}
# Chamar a função
fazer_requisicao(url)
fazer_requisicao <- function(url) {
tryCatch({
response <- GET(url)
status <- status_code(response)
if (status == 200) {
response_text <- content(response, "text", encoding = "UTF-8")  # Correção aqui
data <- fromJSON(response_text)
print(str(data))
print(data)
} else {
cat("Erro na requisição. Status code:", status, "\n")
}
}, error = function(e) {
cat("Ocorreu um erro:", conditionMessage(e), "\n")
}, finally = {
cat("Requisição finalizada.\n")
})
}
# Chamar a função
fazer_requisicao(url)
# Verificando o status da resposta
print(status_code(response))
# Verificando o status da resposta
print(data(response))
# Verificando o status da resposta
print(content(response))
# Verificando o status da resposta
print((response))
# Verificando o status da resposta
print((response[6]))
# Verificando o conteúdo da resposta
print(content(response[6], "content"))
# Verificando o conteúdo da resposta
print(content(response[6], "text"))
# Chamar a função
fazer_requisicao(url)
library(RSQLite)
library(readr)
library(dplyr)
library(tidytext)
library(stringr)
library(lexiconPT)
library(tm)
library(rtweet)
library(RSQLite)
library(readr)
library(dplyr)
library(tidytext)
library(stringr)
library(lexiconPT)
library(tm)
con <-
dbConnect(
RSQLite::SQLite(),
"C:/Users/UEPA_07/Documents/api-mineracao-texts-main/prisma/dev.db"
)
install.packages("RSQLite")
install.packages("DBI")
library(RSQLite)
library(DBI)
con <-
dbConnect(
RSQLite::SQLite(),
"C:/Users/UEPA_07/Documents/api-mineracao-texts-main/prisma/dev.db"
)
tryCatch({
# Nome da tabela no banco de dados
table_name <- "texts"
# Ler a tabela
dados_tabela_texts <- dbReadTable(con, table_name)
# Exibir os dados
print(dados_tabela_texts)
}, error = function(e) {
cat("Ocorreu um erro:", conditionMessage(e), "\n")
}, finally = {
# Fechar a conexão com o banco de dados
dbDisconnect(con)
cat("Conexão com o banco de dados fechada.\n")
})
# Exibir os dados
print(dados_tabela_texts[3])
# Exibir os dados
print(dados_tabela_texts)
# Exibir os dados
print(dados_tabela_texts.3)
# Exibir os dados
print(dados_tabela_texts[1])
# Exibir os dados
print(dados_tabela_texts[2])
# Exibir os dados
print(dados_tabela_texts[3])
# Exibir os dados
print(dados_tabela_texts[4])
dados_tabela_texts["content"== 3]
dados_tabela_texts[,"content"== 3]
dados_tabela_texts[,"content"== 3]
print(dados_tabela_texts)
dados_tabela_texts[dados_tabela_texts$content == 3]
print(dados_tabela_texts)
dados_tabela_texts[dados_tabela_texts$content == 3,]
print(dados_tabela_texts)
dados_tabela_texts[,dados_tabela_texts$content == 3]
print(dados_tabela_texts)
dim(dados_tabela_texts)
names(dados_tabela_texts)
texto_tratado <- dados_tabela_texts$content==3
print(texto_tratado)
texto_tratado <- dados_tabela_texts$content
print(texto_tratado)
texto_tratado <- dados_tabela_texts$content[3]
print(texto_tratado)
dtm_texto <- DocumentTermMatrix(texto_tratado)
library(rvest)
library(stringr)
library(tidytext)
library(dplyr)
library(ggplot2)
library(tidyr)
library(tm)
library(NLP)
library(wordcloud)
library(wesanderson)
library(knitr)
library(rmarkdown)
library(kableExtra)
library(htmltools)
library(prettydoc)
stopwords_portu_df <- data.frame(word = texto_tratado)
texto_token <- texto_token %>%
anti_join(stopwords_portu_df, by = "word")
texto_token %>%
count(word, sort = TRUE)
texto_token %>%
count(word, sort = TRUE) %>%
filter(n > 3) %>%
mutate(word = reorder(word, n)) %>%
ggplot(aes(word, n)) +
geom_col(fill = "#245968") +
xlab(NULL) +
coord_flip() +
labs(y = "Frequência Termos")
